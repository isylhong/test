/**
 * 在threadB中调用threadA.interrupt()后，threadA的中断标志为将由false改为true。并且当threadA响应中断后会重置中断标志为false。
 *
 * 及时响应中断信号的方法：
 * 1、wait()(抛异常)：等待阻塞 -----interrupt-----> 同步阻塞(获取同步锁后变为就绪态)
 * 2、sleep()(抛异常)：其他阻塞 -----interrupt-----> 就绪
 * 3、join()(抛异常)：其他阻塞 -----interrupt-----> 就绪
 * 4、LockSupport.park()(不抛异常)：同步阻塞 -----interrupt-----> 就绪
 *
 * 线程因以下情况进入阻塞(同步阻塞)时不会及时响应中断，但中断信号会被记录(通过设置中断标志位为true来记录)
 * 1、synchronized(monitor){...}
 * 2、ReentrantLock.lock()
 *
 */
public class ThreadInterruptTest {

    /**
     * 不响应中断：情形一
     * ReentrantLock.lock()
     */
    @Test
    public void testReentrantLockInterrupt() throws InterruptedException {
        final ReentrantLock reentrantLock = new ReentrantLock();

        Thread threadA = new Thread(() -> {
            ThreadInfo.print("第1次尝试获取锁");
            reentrantLock.lock();
            ThreadInfo.print("第1次获取到锁，并持锁睡眠3s");
            try {
                Thread.sleep(3000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            ThreadInfo.print("释放第1次获取的锁");
            reentrantLock.unlock();

            int i = 0;
            long nextExecuteTime = System.currentTimeMillis();
            do {
                long currentTimeMillis = System.currentTimeMillis();
                if (nextExecuteTime <= currentTimeMillis) {
                    ThreadInfo.print("运行中...");
                    nextExecuteTime = currentTimeMillis + 500L;
                    i++;
                }
            } while (i <= 1);

            ThreadInfo.print("第2次尝试获取锁");
            reentrantLock.lock();
            ThreadInfo.print("第2次获取到锁");
            ThreadInfo.print("释放第2次获取锁");
            reentrantLock.unlock();
        }, "threadA");
        threadA.start();
        Thread.sleep(1000L); // 保证threadA已运行，获取锁进入阻塞状态

        Thread threadB = new Thread(() -> {
            ThreadInfo.print("尝试获取锁");
            reentrantLock.lock(); // 线程因调用ReentrantLock.lock()进入阻塞(同步阻塞)时不会及时响应中断，但中断信号会被记录(通过设置中断标志位为true来记录)
            ThreadInfo.print("获取到锁");
            try {
                boolean isInterrupted = Thread.currentThread().isInterrupted();
                String info = (isInterrupted ? "发现中断信号" : "为发现中断信号") + "，中断标志位为：" + isInterrupted;
                ThreadInfo.print(info);
                TimeUnit.SECONDS.sleep(1000L); // 线程调用sleep后，因发现中断信号为true，而响应中断
            } catch (InterruptedException e) {
                e.printStackTrace();
                ThreadInfo.print("处理中断，中断标志位为：" + Thread.currentThread().isInterrupted());
            }
            ThreadInfo.print("释放锁");
//            reentrantLock.unlock(); // 不调用unlock()释放锁的话，threadA会一直处于阻塞(同步阻塞)并尝试获取锁
        }, "threadB");
        threadB.start();
        Thread.sleep(1000L); // 确保threadB已开始运行，并因获取不到锁而阻塞(同步阻塞)

        threadB.interrupt();

        Thread.sleep(5000L); // 让主线程睡眠，防止junit原因提前结束线程，影响其他线程对中断信号的响应效果
        ThreadInfo.print("主线程结束");
    }

    /**
     * 不响应中断：情形二
     * synchronized(monitor){...}
     */
    @Test
    public void testSynchronizeInterrupt() throws InterruptedException {
        final Object lock = new Object();

        Thread threadA = new Thread(() -> {
            ThreadInfo.print("第1次尝试获取锁");
            synchronized (lock) {
                ThreadInfo.print("第1次获取到锁，并持锁睡眠3s");
                try {
                    Thread.sleep(3000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                ThreadInfo.print("释放第1次获取的锁");
            }

            int i = 0;
            long nextExecuteTime = System.currentTimeMillis();
            do {
                long currentTimeMillis = System.currentTimeMillis();
                if (nextExecuteTime <= currentTimeMillis) {
                    ThreadInfo.print("运行中...");
                    nextExecuteTime = currentTimeMillis + 500L;
                    i++;
                }
            } while (i <= 1);

            ThreadInfo.print("第2次尝试获取锁");
            synchronized (lock) {
                ThreadInfo.print("第2次获取到锁");
                ThreadInfo.print("释放第2次获取锁");
            }
        }, "threadA");
        threadA.start();
        Thread.sleep(1000L); // 保证threadA已运行，获取锁进入阻塞状态

        Thread threadB = new Thread(() -> {
            ThreadInfo.print("尝试获取锁");
            synchronized (lock) {
                ThreadInfo.print("获取到锁");
                try {
                    boolean isInterrupted = Thread.currentThread().isInterrupted();
                    String info = (isInterrupted ? "发现中断信号" : "为发现中断信号") + "，中断标志位为：" + isInterrupted;
                    ThreadInfo.print(info);
                    // 线程因synchronize(){...}进入阻塞(同步阻塞)时不会及时响应中断，但中断信号会被记录(通过设置中断标志位为true来记录)
                    TimeUnit.SECONDS.sleep(1000L); // 线程调用sleep后，因发现中断信号为true，而响应中断
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    ThreadInfo.print("处理中断，中断标志位为：" + Thread.currentThread().isInterrupted());
                }
                ThreadInfo.print("释放锁");
//                while (true); // 模拟threadB不释放获取到的锁，此时threadA会一直处于阻塞(同步阻塞)并尝试获取锁
            }
        }, "threadB");
        threadB.start();
        Thread.sleep(1000L); // 确保threadB已开始运行，并因获取不到锁而阻塞(同步阻塞)

        threadB.interrupt();

        Thread.sleep(5000L); // 让主线程睡眠，防止junit原因提前结束线程，影响其他线程对中断信号的响应效果
        ThreadInfo.print("主线程结束");
    }

    /**
     * 响应中断：情形一
     * LockSupport.lock()，不抛异常
     */
    @Test
    public void testLockSupportInterrupt() throws InterruptedException {
        Thread threadA = new Thread(() -> {
            ThreadInfo.print("threadA开始运行");
            ThreadInfo.print("调用LockSupport.park()进入阻塞状态");
            LockSupport.park();
            String msg = Thread.currentThread().isInterrupted() ? "因中断而提前结束阻塞" : "调用LockSupport.unpark()获取到锁介素阻塞";
            ThreadInfo.print(msg + "，中断标志位: " + Thread.currentThread().isInterrupted());
        }, "threadA");
        threadA.start();

        Thread.sleep(2000L); // 确保threadA已经开始运行了
        ThreadInfo.print("准备向threadA发送中断信号，threadA的中断标志位为：" + threadA.isInterrupted());
        threadA.interrupt();
        ThreadInfo.print("向threadA发送中断信号后，threadA的中断标志位为：" + threadA.isInterrupted());
//        LockSupport.unpark(threadA);

        Thread.sleep(3000L); // 让主线程睡眠，防止junit原因提前结束线程，影响其他线程对中断信号的响应效果
        ThreadInfo.print("主线程结束");
    }

    /**
     * 响应中断：情形二
     * threadA.join()，抛异常。
     * 因join()方法进入阻塞状态的线程会响应中断信号，被join的线程不会响应中断且继续运行。
     * threadB中调用threadA.join()，threadB 进入阻塞(其他阻塞) -> ThreadB调用interrupt，产生中断信号 -> threadB响应中断信号，进入就绪状态。
     *
     * main                 threadA            threadB
     * running
     * -                    running
     * -                    -                  running
     * -                    -                  threadA.join()
     * -                    running            block(其他阻塞)
     * running              -                  block(其他阻塞)
     * threadB.interrupt()  -
     * -                    -                  running，响应中断，处理中断
     * -                    running            结束线程
     * running              -
     * 结束线程             因main线程结束而终止
     */
    @Test
    public void testJoinInterrupt() throws InterruptedException {
        ThreadInfo.print("启动主线程");

        final Thread threadA = new Thread(() -> {
            ThreadInfo.print("threadA开始运行");
            long nextExecuteTime = System.currentTimeMillis() + 500L;
            while (true) {
                long currentTimeMillis = System.currentTimeMillis();
                if (nextExecuteTime <= currentTimeMillis) {
                    ThreadInfo.print("继续运行");
                    nextExecuteTime = currentTimeMillis + 500L;
                }
            }
        }, "threadA");
        threadA.start();
        Thread.sleep(1000L); // 确保threadA已经开始运行了

        Thread threadB = new Thread(() -> {
            try {
                ThreadInfo.print("启动threadB");
                ThreadInfo.print("join threadA，进入阻塞状态(其他阻塞)");
                threadA.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
                ThreadInfo.print("处理中断异常");
            }
            ThreadInfo.print("结束线程");
        }, "threadB");
        threadB.start();

        Thread.sleep(3000L); // 确保threadB已经开始运行了
        ThreadInfo.print("向threadB发送中断信号");
        threadB.interrupt(); // 向线程threadB发送中断信号

        Thread.sleep(2000L); // 让主线程睡眠，防止junit原因提前结束线程，影响其他线程对中断信号的响应效果
        ThreadInfo.print("主线程结束");
    }

    /**
     * 响应中断：情形三
     * Object.wait()，因wait()方法进入等待阻塞的线程会响应中断信号
     * 调用wait，进入阻塞(等待阻塞) -> 调用interrupt，产生中断信号 -> 响应中断信号，进入阻塞状态(同步阻塞，因未获取到锁而阻塞) -> 获取到同步锁，进入就绪状态
     */
    @Test
    public void testWaitInterrupt() throws InterruptedException {
        final Object lock = new Object();
        Thread threadA = new Thread(() -> {
            synchronized (lock) {
                try {
                    ThreadInfo.print("获取到同步监视器，调用wait()进入等待状态");
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    ThreadInfo.print("中断异常处理");
                }
            }
            ThreadInfo.print("执行结束");
        }, "threadA");
        threadA.start();

        Thread.sleep(1000L);

        // 向线程threadA发送中断信号
        ThreadInfo.print("向threadA发送中断信号");
        threadA.interrupt();

        Thread.sleep(5000L); // 让主线程睡眠，防止junit原因提前结束线程，影响其他线程对中断信号的响应效果
        ThreadInfo.print("主线程结束");
    }

    /**
     * 不响应中断：情形四
     * Thread.sleep()，抛异常。
     * 因sleep()方法进入其他阻塞的线程会响应中断信号。
     * 调用sleep，进入阻塞状态(等待阻塞)  -> 调用interrupt，产生中断信号 -> 响应中断信号，进入就绪状态
     */
    @Test
    public void testSleepInterrupt() throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                ThreadInfo.print("调用sleep()开始睡眠，进入等待状态");
                Thread.sleep(3000L);
                ThreadInfo.print("发现中断信号");
            } catch (InterruptedException e) {
                e.printStackTrace();
                ThreadInfo.print("中断异常处理");
            }
            ThreadInfo.print("执行结束");
        }, "threadA");
        thread.start();

        Thread.sleep(1000L);

        // 向线程threadA发送中断信号
        ThreadInfo.print("向threadA发送中断信号");
        thread.interrupt();

        Thread.sleep(5000L); // 让主线程睡眠，防止junit原因提前结束线程，影响其他线程对中断信号的响应效果
        ThreadInfo.print("主线程结束");
    }

    /**
     * 线程中断信号不会影响(中断)处于运行态的线程
     */
    @Test
    public void testWhileInterrupt() throws InterruptedException {
        Thread thread = new Thread(() -> {
            ThreadInfo.print("无限循环处理");
            while (true) ;
        }, "threadA");
        thread.start();

        Thread.sleep(1000L);

        // 向线程threadA发送中断信号
        ThreadInfo.print("向threadA发送中断信号");
        thread.interrupt();

        Thread.sleep(5000L); // 让主线程睡眠，防止junit原因提前结束线程，影响其他线程对中断信号的响应效果
    }

    static class ThreadInfo {
        public static void print(String msg) {
            Thread thread = Thread.currentThread();
            SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
            String timeStr = sdf.format(new Date());
            System.out.println(timeStr + " [" + thread.getName() + "]" + msg);
        }
    }
}



public class ThreadPoolTest {

    /**
     * 使用不同二进制值表示的ThreadPoolExecutor各状态
     */
    @Test
    public void testThreadPoolExecutorState() {
        int COUNT_BITS = Integer.SIZE - 3;

        int CAPACITY = (1 << COUNT_BITS) - 1;
        System.out.println("CAPACITY    " + Utils.NumberUtil.toBinaryString32(CAPACITY)); // CAPACITY与ctl
        // 做&运算，可计算线程池目前已开启了的Worker线程数
        System.out.println("~CAPACITY   " + Utils.NumberUtil.toBinaryString32(~CAPACITY)); // ~CAPACITY与ctl做&运算，可计算线程池的状态

        // 二进制指定N个高bit位用于表示线程池的5种状态
        int RUNNING = -1 << COUNT_BITS;
        int SHUTDOWN = 0 << COUNT_BITS;
        int STOP = 1 << COUNT_BITS;
        int TIDYING = 2 << COUNT_BITS;
        int TERMINATED = 3 << COUNT_BITS;
        System.out.println("RUNNING     " + Utils.NumberUtil.toBinaryString32(RUNNING));
        System.out.println("SHUTDOWN    " + Utils.NumberUtil.toBinaryString32(SHUTDOWN));
        System.out.println("STOP        " + Utils.NumberUtil.toBinaryString32(STOP));
        System.out.println("TIDYING     " + Utils.NumberUtil.toBinaryString32(TIDYING));
        System.out.println("TERMINATED  " + Utils.NumberUtil.toBinaryString32(TERMINATED));

        /*
        初始化线程池，ctl值初始化为：11100000 00000000 00000000 00000000，表示线程池处于RUNNING状态，开启的worker线程数为0。
        线程池启动后，只要线程池处于运行状态，ctl的高3bit位就是111，
        也就是说：ctl值为负数，可以推断出线程池处于RUNNING状态；线程池处于RUNNING状态，也可以推断出ctl值为负数。
         */
        int ctl = RUNNING | 0;
        System.out.println("线程池初始化，ctl值初始化为:         " + Utils.NumberUtil.toBinaryString32(ctl));
        int runState = RUNNING & ~CAPACITY;
        System.out.println("runStateOf(c & ~CAPACITY):      " + Utils.NumberUtil.toBinaryString32(runState));
        int workerCount = ctl & CAPACITY;
        System.out.println("workerCountOf(ctl & CAPACITY):    " + Utils.NumberUtil.toBinaryString32(workerCount));

        // 1+3位
        // 1100 1011->1100
        // 1111 1000->1001

        System.out.println("-1:     " + Utils.NumberUtil.toBinaryString32(-1));
        int bit_count = -1 >>> 1;
        System.out.println("-1>>>1: " + Utils.NumberUtil.toBinaryString32(bit_count));
    }

    /**
     *线程池中线程中断问题
     *
     * 假设线程池中只有一个threadA，任务队列中有task1，task2，task3，且threadA已经获取到task1并处于运行态。
     * 问：
     *  1、如果这是向threadA发送一个中断信号，线程会被中断运行吗？
     *  答：不会。
     *      threadA.interrupt()方法只是向threadA发送一个中断信号，并置threadA的中断表示位为true。因此，无法通过threadA.interrupt()让一个处于运行的task及时停止运行。
     *      想要通过中断来停止一个运行中的task，正确的做法是在task代码中手动调用Thread.isInterrupted()
     *      去检查中断标志位是否为ture以确定当前线程是否有中断信号。如果有中断信号，则需手动终止线程运行。
     *
     *  2、向运行中的threadA发送一个中断信号后，task1并未停止运行，threadA中断标志位被设置为true了。那么，threadA的中断标志是在什么时候被重置为false的？
     *  答：threadA的中断标志是在threadA向线程池任务队列（1个BlockQueue）获取任务（getTask()方法）的时候被重置为false的。
     *      workQueue.take()方法在获取task的时候会先通过ReentrantLock.lockInterruptibly()上锁，而上锁的过程会检查当前访问线程是否有中断信号(中断标志位是否位true)，
     *      如果当前访问线程有中断信号，则重置当前线程中断标志位为false，并抛出InterruptedException。此时，便可在getTask()方法中捕获这个中断异常。
     *
     *  3、向正在运行task1的threadA发送一个中断信号，threadA会继续获取任务队列中的task2、task3来运行吗？
     *  答：会。
     *      向运行中的threadA发送一个中断信号(threadA的中断标志位被设置为true)，threadA会在运行完task1再次调用getTask()获取任务的时候处理中断
     *      (重置threadA的中断标志位为false)。然后继续调用getTask()获取task2来执行。
     *
     */
    @Test
    public void testFutureTask() throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newFixedThreadPool(1);
        final AtomicInteger count = new AtomicInteger(1);
        Callable<String> callable = () -> {
            ThreadInterruptTest.ThreadInfo.print("1开始运行");
            int i = 0;
            long nextExecuteTime = System.currentTimeMillis();
            do {
                long currentTimeMillis = System.currentTimeMillis();
                if (nextExecuteTime <= currentTimeMillis) {
                    ThreadInterruptTest.ThreadInfo.print(" i'm running...");
                    nextExecuteTime = currentTimeMillis + 1000L;
                    i++;
                }
            } while (i <= 4);
            ThreadInterruptTest.ThreadInfo.print("1结束运行");
            return "result-" + count.getAndIncrement();
        };

        Future<String> future = executorService.submit(callable);

        Thread.sleep(2000L); // 确保callable已经运行了
        ThreadInterruptTest.ThreadInfo.print("调用cancel()尝试取消处于运行中的future task1");
        future.cancel(true);  // cancel无法停止一个已处于运行态的线程，只能等待线程运行完自己终止

        try {
            System.out.println(future.get()); // 取消一个运行中的task后，当前线程调用future.get()会报CancellationException异常
        } catch (CancellationException e) { // 不捕获这个异常会造成当前异常因异常停止运行，进而提前终止callable的运行
            System.out.println("发现任务被取消，调用get()方法的线程抛出CancellationException异常，但线程实际并未停止，会运行直到结束");
        }


        Thread.sleep(20 * 1000L);
        ThreadInterruptTest.ThreadInfo.print("主线程结束运行！");
    }

    @Test
    public void testThreadPoolExecutorCreate() {
        ExecutorService executorService = new ThreadPoolExecutor(0, 1, 1L, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(1), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());

        Runnable runnable = () -> {
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("I'm a quick task");
//            while (true) ;
        };
        for (int i = 0; i < 1; i++) {
            executorService.submit(runnable);
        }

        executorService.shutdown(); // 线程池调用shutdown方法后将不再接收执行新提交的线程任务，但会让已提交到线程池中的线程执行完。
        try {
            // 线程池调用awaitTermination方法后会阻塞该线程，直到线程池中所有线程执行完。设置一个等待时间，
            // 返回true: 在等待时间内线程池内所有task都执行完。
            // 返回false: 超过等待时间后，线程池内存在未执行完task。同时强制结束未执行完的task。
            boolean isFinishAll = executorService.awaitTermination(2000, TimeUnit.MILLISECONDS); // false, 未执行完任务便关闭线程池
//            executorService.awaitTermination(3000, TimeUnit.MILLISECONDS); // false, 现象怪异
//            executorService.awaitTermination(5000, TimeUnit.MILLISECONDS); // true, 所有任务均执行完，关闭线程池
            System.out.println(isFinishAll);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}




public class WaitAndNotifyTest {

    /**
     * class 04
     * 使用wait()、notify()、notifyAll()模拟CountDownLatch
     */
    @Test
    public void testWaitAndNotify() {
        Monitor monitor = new Monitor(2);
        Object obj = new Object();

        Thread waiterA = new Thread(new Waiter(monitor, obj), "<waiterA>");
        waiterA.start();

        Thread waiterB = new Thread(new Waiter(monitor, obj), "<waiterB>");
        waiterB.start();

        Thread notifier = new Thread(new Notifier(monitor, obj), "<notifier>");
        notifier.start();

        while (!monitor.isFinish());

//        try {
//            Thread.sleep(10000L);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
    }

    /**
     * class 01
     */
    class Monitor {
        private final AtomicInteger index;
        private final int part;

        public Monitor(int part) {
            this.part = part;
            index = new AtomicInteger(0);
        }

        public boolean isLastFinished() {
            return index.incrementAndGet() == part;
        }

        public boolean isFinish() {
            return index.intValue() == part;
        }
    }

    /**
     * class 02
     */
    class Notifier implements Runnable {
        private final Monitor monitor;
        private final Object obj;

        public Notifier(Monitor monitor,Object obj) {
            this.monitor = monitor;
            this.obj=obj;
        }

        @Override
        public void run() {
            try {
                String threadName = Thread.currentThread().getName();
                System.out.println(threadName + " begin run");

                Thread.sleep(1000L); // 模拟线程执行

                System.out.println(threadName + " notify other worker and waiting done.");
                synchronized (monitor) {
                    monitor.notifyAll();
                }
                synchronized (obj) {
                    obj.wait();
                }
                System.out.println(threadName + " wake up, and continue run...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * class 03
     */
    class Waiter implements Runnable {
        private final Monitor monitor;
        private final Object obj;

        public Waiter(Monitor monitor, Object obj) {
            this.monitor = monitor;
            this.obj = obj;
        }

        @Override
        public void run() {
            try {
                String threadName = Thread.currentThread().getName();

                System.out.println(threadName + " are ready!");
                synchronized (monitor) {
                    monitor.wait(); // 阻塞
                }

                System.out.println(threadName + " start running");
                //
                Thread.sleep(2000L); // 模拟线程执行

                System.out.println(threadName + " finish, notify one worker continue work.");

                if (monitor.isLastFinished()) {
                    synchronized (obj){
                        obj.notify();
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
